# set seed for random
# number generation
X<-rnorm(n,mean=mu,sd=sigma)
hist(X,prob=T,breaks=15,ylim=c(0,0.17))
# histogram
curve(f,add=T,col="red")
boxplot(X)
qqnorm(X)
qqline(X)
which(abs(scale(X))>qnorm(0.99))
sum(abs(scale(X))>qnorm(0.99))/n
1-0.99
rm(list=ls())
Sigma<-matrix(c(3^2,0.5*3*2,0.5*3*2,2^2),2,2); Sigma
# population covariance matrix
mu.1<-0;mu.2<-2
mu<-c(mu.1, mu.2); mu
set.seed(1)
X<-mvrnorm(n=1000, mu, Sigma)
plot(X[,1],X[,2],xlim=c(-12,12),
xaxs="i",yaxs="i",asp=1,xlab="x1",ylab="x2")
bar.x<-colMeans(X); bar.x
# sample mean vector
mu
# should be close
points(bar.x[1],bar.x[2],pch=21,cex=1.2,bg="red",col="white")
# center of the scatter plot
abline(h=0,v=0)
S<-cov(X);  round(S,2)
# sample covarince matrix
Sigma
# should be close
round(cor(X),6)
beta.0<-mu.2-mu.1*0.5*2/3
# intercept of true
# mean regression line
beta.1<-0.5*2/3
abline(a=beta.0,b=beta.1,lwd=2,col="blue")
fit<-lm(X[,2]~X[,1]);
coef(fit)
beta.0;beta.1
hat.beta.0<-coef(fit)[1];hat.beta.1<-coef(fit)[2]
abline(a=hat.beta.0,b=hat.beta.1,lwd=2,col="green")
# least square estimate
# of regression line
abline(fit,lwd=2,col="green")
lines(ellipse(x=Sigma,centre=mu,level=0.95),col="red",lwd=1.5)
lines(ellipse(x=Sigma,centre=mu,level=0.75),col="red",lwd=1.5)
lines(ellipse(x=Sigma,centre=mu,level=0.50),col="red",lwd=1.5)
# axes of the ellipsoid
eigen.X<-eigen(Sigma)
# spectral decomposition
eigen.X
P<-eigen.X$vectors
# orthogonal matrix
t(P)%*%P
lambda<-eigen.X$values
# eigenvalues
e1<-P[,1];e2<-P[,2]
crossprod(e1,e2)
# orthogonal to each other
b<-e1[2]/e1[1]
# slope of 1st axis
a<--b*mu.1+mu.2
# intercept of 1st axis
abline(a=a,b=b,lwd=2,col="red")
b<-e2[2]/e2[1]
# slope of 2nd axis
a<--b*mu.1+mu.2
# intercept of 2nd axis
abline(a=a,b=b,lwd=2,col="red")
# slope is also given by
# -e_11/e_12
# obtained from equation
# z_1=e_11(y_1-mu_1)
#     +e_12(y_2-mu_2)
# by setting z_1=0
cc<-sqrt(qchisq(0.95, 2))
x<-cbind(cc*sqrt(lambda[1])*e1+mu,
-cc*sqrt(lambda[1])*e1+mu,
cc*sqrt(lambda[2])*e2+mu,
-cc*sqrt(lambda[2])*e2+mu)
x
points(x[1,],x[2,],pch=21,bg="brown")
arrows(x[1,1],x[2,1],x[1,2],x[2,2],code=2,col="brown",lwd=3)
arrows(x[1,3],x[2,3],x[1,4],x[2,4],code=2,col="brown",lwd=3)
plot(X[,1],X[,2],xlim=c(-12,12),
xaxs="i",yaxs="i",asp=1,xlab="x1",ylab="x2")
points(mu[1],mu[2],pch=21,cex=1.2,col="white",bg="red")
lines(ellipse(x=Sigma,centre=mu,level=0.95),col="red",lwd=1.5)
lines(ellipse(x=Sigma,centre=mu,level=0.75),col="red",lwd=1.5)
lines(ellipse(x=Sigma,centre=mu,level=0.50),col="red",lwd=1.5)
abline(a=beta.0,b=beta.1,lwd=2,col="blue")
arrows(x[1,1],x[2,1],x[1,2],x[2,2],code=2,col="brown",lwd=3)
arrows(x[1,3],x[2,3],x[1,4],x[2,4],code=2,col="brown",lwd=3)
det.S<-det(Sigma); Sigma.inv<-solve(Sigma)
f<-function(x) (det.S*(2*pi)^(length(x)/2))^(-1)*
exp(-t(x-mu)%*%Sigma.inv%*%(x-mu)/2)
nbins <- 50+1
x.bin <- seq(-20, 20, length=nbins)
y.bin <- seq(-8, 12, length=nbins)
grid<-expand.grid(x.bin,y.bin)
z.val<-apply(grid,1,f)
# evaluation of bivariate
# density on the grid
g2<-data.frame(x=x.bin,y=y.bin,z=z.val)
# pdf("../graphics/bivar_norm2.pdf",paper="special")
# 3D plot
wireframe(z~x*y,g2,screen=list(z=-70,x=-60),shade=T,
lwd=0.1,light.source=c(0,10,10),
xlab=expression(x[1]),ylab=expression(x[2]),
zlab="density",main="multivariate normal",
shade.colors = function(irr, ref, height, w = 0.4)
grey(w*irr+(1-w)*(1 - (1 - ref)^0.4)) )
plot(c(0,0),c(0,0),xlim=c(-20,20), ylim=c(-8,12),
xaxs="i",yaxs="i",asp=1,
xlab=expression(x[1]),ylab=expression(x[2]),,type="n")
# contour plots
lines(ellipse(x=Sigma,centre=mu,level=0.95),col="red",lwd=1.5)
lines(ellipse(x=Sigma,centre=mu,level=0.75),col="red",lwd=1.5)
lines(ellipse(x=Sigma,centre=mu,level=0.5),col="red",lwd=1.5)
points(mu.1,mu.2,pch=16,cex=1.2,col="red")
# dev.off()
# increase variances
# of x_1 and y_2
Sigma <- matrix(c(5^2,0.5*5*3,0.5*5*3,3^2),2,2)
det.S<-det(Sigma); Sigma.inv<-solve(Sigma)
z.val<-apply(grid,1,f)
g2<-data.frame(x=x.bin,y=y.bin,z=z.val)
wireframe(z~x*y,g2,screen=list(z=-70,x=-60),shade=T,
lwd=0.1,light.source=c(0,10,10),
xlab=expression(x[1]),ylab=expression(x[2]),
zlab="density",main="multivariate normal",
shade.colors = function(irr, ref, height, w = 0.4)
grey(w*irr+(1-w)*(1 - (1 - ref)^0.4)) )
plot(c(0,0),c(0,0),xlim=c(-20,20), ylim=c(-8,12),
xaxs="i",yaxs="i",asp=1,
xlab=expression(x[1]),ylab=expression(x[2]),,type="n")
# contour plots
lines(ellipse(x=Sigma,centre=mu,level=0.95),col="red",lwd=1.5)
lines(ellipse(x=Sigma,centre=mu,level=0.75),col="red",lwd=1.5)
lines(ellipse(x=Sigma,centre=mu,level=0.5),col="red",lwd=1.5)
points(mu.1,mu.2,pch=16,cex=1.2,col="red")
Sigma <- matrix(c(3^2,0.3*3*2,0.3*3*2,2^2),2,2)
det.S<-det(Sigma); Sigma.inv<-solve(Sigma)
nbins <- 50+1
x.bin <- seq(-15, 15, length=nbins)
y.bin <- seq(-6, 10, length=nbins)
grid<-expand.grid(x.bin,y.bin)
z.val<-apply(grid,1,f)
g2<-data.frame(x=x.bin,y=y.bin,z=z.val)
wireframe(z~x*y,g2,screen=list(z=-70,x=-60),shade=T,
lwd=0.1,light.source=c(0,10,10),
xlab=expression(x[1]),ylab=expression(x[2]),
zlab="density",main="multivariate normal",
shade.colors = function(irr, ref, height, w = 0.4)
grey(w*irr+(1-w)*(1 - (1 - ref)^0.4)) )
plot(c(0,0),c(0,0),xlim=c(-15,15), ylim=c(-6,10),
xaxs="i",yaxs="i",asp=1,
xlab=expression(x[1]),ylab=expression(x[2]),type="n")
lines(ellipse(x=Sigma,centre=mu,level=0.95),col="red",lwd=1.5)
lines(ellipse(x=Sigma,centre=mu,level=0.75),col="red",lwd=1.5)
lines(ellipse(x=Sigma,centre=mu,level=0.5),col="red",lwd=1.5)
points(mu.1,mu.2,pch=16,cex=1.2,col="red")
# increase correlation
# among x_1 and x_2
Sigma <- matrix(c(3^2,0.8*3*2,0.8*3*2,2^2),2,2)
det.S<-det(Sigma); Sigma.inv<-solve(Sigma)
z.val<-apply(grid,1,f)
g2<-data.frame(x=x.bin,y=y.bin,z=z.val)
wireframe(z~x*y,g2,screen=list(z=-70,x=-60),shade=T,
lwd=0.1,light.source=c(0,10,10),
xlab=expression(x[1]),ylab=expression(x[2]),
zlab="density",main="multivariate normal",
shade.colors = function(irr, ref, height, w = 0.4)
grey(w*irr+(1-w)*(1 - (1 - ref)^0.4)) )
plot(c(0,0),c(0,0),xlim=c(-15,15), ylim=c(-6,10),
xaxs="i",yaxs="i",asp=1,
xlab=expression(x[1]),ylab=expression(x[2]),type="n")
lines(ellipse(x=Sigma,centre=mu,level=0.95),col="red",lwd=1.5)
lines(ellipse(x=Sigma,centre=mu,level=0.75),col="red",lwd=1.5)
lines(ellipse(x=Sigma,centre=mu,level=0.5),col="red",lwd=1.5)
points(mu.1,mu.2,pch=16,cex=1.2,col="red")
rm(list=ls())
stiff<-read.table("data/stiffness.txt",header=FALSE)
dim(stiff)
names(stiff)<-c("x1","x2","x3","x4","d^2")
stiff[1:5,]
stiff[1:5,1:4]
stiff[1:5,-5]
j<-1
x<-stiff[,j]
mean(x)
var(x)
qqnorm(x,pch=16,main="Q-Q plot for x1")
qqline(x,col="red")
rm(list=ls())
stiff<-read.table("data/stiffness.txt",header=FALSE)
library(ellipse)
rm(list=ls())
mineral<-read.table("data/mineral.txt",header=TRUE)
head(mineral)
rm(list=ls())
mineral<-read.table("data/mineral.txt",header=TRUE)
library(ellipse)
rm(list=ls())
mineral<-read.table("data/mineral.txt",header=TRUE)
head(mineral)
setwd("~/Documents/PhD/MATERIE/MULTIVARIATE STATISTICAL ANALYSIS/Lecture_MultivNorm")
rm(list=ls())
mineral<-read.table("data/mineral.txt",header=TRUE)
head(mineral)
# x1 : dominant radius
# x2 : radius
# x3 : dominant humerus
# x4 : humerus
# x5 : dominant ulna
# x6 : ulna
dim(mineral)
names(mineral)<-c("dradius","radius","dhumerus","humerus","dulna","ulna")
head(mineral)
bar.x<-colMeans(mineral)
bar.x
plot(bar.x,type="h",lwd=3,ylim=c(0,max(bar.x)),axes=F,xlab="",ylab="mean")
title(main="Mineral data")
box()
axis(2)
# axis(1,at=1:6,labels=names(mineral),cex.axis=0.8)
# ?axis
axis(1,at=1:6,labels=names(mineral),las=3)
S<-cov(mineral)
round(S,3)
S<-cov(mineral)
round(S,3)
det(S)
eigen(S)$values
plot(eigen(S)$values,type="h",lwd=3,ylab="eigenvalues",
main="Mineral data")
R<-cor(mineral)
round(R,3)
#                                     # which are the pairs of variables
#                                     # with the largest correlations?
# lower.tri(R)
R[!lower.tri(R)]<-NA
R
sort(abs(R),decreasing=T)
#                                     # need the position in the correlation
#                                     # matrix of the largest collelations
order(abs(R),decreasing=T)
#                                     # with the ranks of NA
#                                     # only first 15 ranks are needed
p<-dim(mineral)[2]; p
stack.m<-matrix(1:p^2,ncol=p); stack.m
order(abs(R),decreasing=T,na.last = NA)
order.cor<-order(abs(R),decreasing=T,na.last = NA)
order.cor
which(stack.m==order.cor[1])
#                                     # what is the position of the
#                                     # largest correlation?
which(stack.m==order.cor[1],arr.ind=T)
which(stack.m==order.cor[2],arr.ind=T)
which(stack.m==order.cor[1:2],arr.ind=T)
#                                     # it does not work in vectorized form
my.fun<-function(x) which(stack.m==x,arr.ind=T)
my.fun<-Vectorize(my.fun)
#                                     # make it a vectorized function
my.fun(order.cor[1])
my.fun(order.cor[1:2])
my.fun(order.cor[1:3])
#                                     # ok, but we like them arranged as rows
Order.cor<-t(my.fun(order.cor))
Order.cor
#                                     # that's it!
colnames(Order.cor)<-c("row","col")
#                                     # add column names
Order.cor
#                                     # the largest correlation is
#                                     # between 4th and 3rd var
#                                     # nice to have the var names instead
out<-matrix(names(mineral)[Order.cor],ncol=2)
colnames(out)<-c("row","col")
out
round(R,3)
round(sort(abs(R),decreasing=T),3)
j<-1
j<-1
x<-mineral[,j]
hist(x,prob=T)
lines(density(x))
# main.lab<-substitute(j,list(j=names(mineral)[j]))
# main.lab<-paste("Histogram of ",names(mineral)[j])
main.lab<-names(mineral)[j]
# main.lab
plot(density(x),main=main.lab,xlab="mineral content")
hist(x,prob=T,add=T)
# qqnorm(x)
# main.lab<-paste("Normal Q-Q plot of ",substitute(j,list(j=names(mineral)[j])),sep="")
main.lab<-paste("Normal Q-Q plot of ",names(mineral)[j],sep="")
main.lab
qqnorm(x,main=main.lab)
qqline(x)
n<-dim(mineral)[1]
(1:n-0.5)/n
ppoints(x)
plot(qnorm(ppoints(x)),sort(x))
qqnorm(x,main=main.lab)
points(qnorm(ppoints(x)),sort(x),pch=16)
qqline(x)
abline(a=mean(x),b=sd(x),col="red")
qqnorm(x,main=main.lab,cex=0.5,pch=16)
qqline(x)
text(qnorm(ppoints(x)),sort(x),label=order(x),
pos=4,cex=0.75,offset=0.4)
j<-1; k<-2
delta<-0.055
# x.lab<-substitute(j,list(j=names(mineral)[j]))
x.lab<-names(mineral)[j]
# y.lab<-substitute(j,list(j=names(mineral)[k]))
y.lab<-names(mineral)[k]
plot(mineral[,j],mineral[,k],pch=16,asp=1,
# xlim=c(min(mineral[,j]-delta),max(mineral[,j])+delta),
ylim=c(min(mineral[,k]-delta),max(mineral[,k])+delta),
xlab=x.lab,ylab=y.lab,main="Mineral content data")
lines(ellipse(x=S[c(j,k),c(j,k)],
centre=bar.x[c(j,k)],
level=0.95),
col="red",lwd=1.5)
points(bar.x[j],bar.x[k],cex=1.2,pch=21,bg="red")
P<-eigen(S[c(j,k),c(j,k)])$vectors;e1<-P[,1];e2<-P[,2]
lambda<-eigen(S[c(j,k),c(j,k)])$values
b<-e1[2]/e1[1]
a<-bar.x[k]-b*bar.x[j]
abline(a,b,col="red")
b<-e2[2]/e2[1]
a<-bar.x[k]-b*bar.x[j]
abline(a,b,col="red")
cc<-qchisq(0.95,df=2); cc
x<-sqrt(cc)*cbind(sqrt(lambda[1])*e1,
-sqrt(lambda[1])*e1,
sqrt(lambda[2])*e2,
-sqrt(lambda[2])*e2)+bar.x[c(j,k)]
x
# points(x[1,],x[2,])
# ?arrows
arrows(x[1,1],x[2,1],x[1,2],x[2,2],code=2,lwd=2,col="brown",length=0.1)
arrows(x[1,3],x[2,3],x[1,4],x[2,4],code=2,lwd=2,col="brown",length=0.1)
pairs(mineral,pch=16,cex=0.5,lower.panel=NULL)
pairs(mineral,pch=16,cex=0.5,upper.panel=panel.smooth,lower.panel=NULL)
X<-mineral
# one<-rep(1,n)
# D<-as.matrix(X-one%*%t(bar.x))
D<-scale(X,scale=F)
d<-rep(0,n)
for(i in 1:n) d[i]<-t(D[i,])%*%solve(S)%*%D[i,]
help("mahalanobis")
X<-mineral
X<-DF
setwd("~/Documents/PhD/MATERIE/MULTIVARIATE STATISTICAL ANALYSIS/problemSet1/MultivariateStatAnalysis")
X<-DF
rm(list=ls())
usair <- read.table("data/usair.txt", header = TRUE)
# converto a dataframe
DF <- as.data.frame(usair)
head(DF)
# cancello la colonna da ignorare
DF$SO2 <- NULL
head(DF)
# "Neg.Temp" "Manuf"  "Pop"   "Wind"  "Precip"  "Days"
#names(DF) <- paste("x",1:6,sep="")
names(DF) <- c('x1','x2','x3','x4','x5','x6')
attach(DF)
# 1)
# Media di ciascuna colonna
x_bar <- colMeans(DF)
# matrice di correlazione e covarianza
Cors <- cor(DF)
varcov <- cov(DF)
x_bar
Cors
varcov
# commentare le correlazioni
'
COMMENTI
'
boxplot(x1)
which(x1 < -71)   #9 Miami
boxplot(x2)
which(x2 > 1500)  #11 29  Chicago(+3000) e philadelphia
boxplot(x3)
which(x3 > 1600)  #come sopra
# parentesi su x2 e x3
div = x2/x3 # fabbriche con >20 lavoratori per ogni 1k abitanti
boxplot(div) # ci sono città con tante fabbriche in rapp agli abitanti
which(div > 1.3) #5 27 31  Hartford Cleveland Providence
boxplot(x4) # ok
boxplot(x5)
which(x5 < 10)  #1 23 Phoenix Alburquerque
boxplot(x6)
which(x6<60) #stessi due
DF_centr = sweep(DF,2,x_bar) # tolgo la media ad ogni riga
names(DF_centr) <- c('m1','m2','m3','m4','m5','m6')
attach(DF_centr)
varianze = diag(varcov) # estraggo le varianze delle colonne
for (i in 1:6){
DF_centr[,i] <- DF_centr[,i]/varianze[i]
} # calcolo le distanze per ogni osservazione per ogni colonna
# 3)
install.packages("moments")
library(moments)
qqnorm(x1,pch=16,main="Q-Q plot for x1")
install.packages("moments")
qqline(x1,col="red") #quite normal
skewness(x1)
qqnorm(x2,pch=16,main="Q-Q plot for x2")
qqline(x2,col="red") #right skew distribution
skewness(x2)
qqnorm(x3,pch=16,main="Q-Q plot for x3")
qqline(x3,col="red") #right skew distribution
skewness(x3)
qqnorm(x4,pch=16,main="Q-Q plot for x4")
qqline(x4,col="red") #normal
skewness(x4)
qqnorm(x5,pch=16,main="Q-Q plot for x5")
qqline(x5,col="red") #little left skewness
skewness(x5)
qqnorm(x6,pch=16,main="Q-Q plot for x6")
qqline(x6,col="red") #normal
skewness(x6)
# 4)
# plotto i scatterplot per ogni coppia di variabili piazzando sui grafici
# l'indice dell'istanza
n <- dim(DF)[1]
the.labels <- 1:n
pairs(DF, panel = function(x, y) text(x, y, labels = the.labels))
# 5)
qqplot(qchisq(ppoints(x1),df=4),x1,pch=16,main="X1")
qqplot(qchisq(ppoints(x2),df=4),x2,pch=16,main="X2")
X<-DF
# one<-rep(1,n)
# D<-as.matrix(X-one%*%t(bar.x))
D<-scale(DF,scale=F)
d<-rep(0,n)
# 6)
## multivariate normality
n<-dim(DF)[1]
n
X<-DF
# one<-rep(1,n)
# D<-as.matrix(X-one%*%t(bar.x))
D<-scale(DF,scale=F)
d<-rep(0,n)
for(i in 1:n) d[i]<-t(D[i,])%*%solve(S)%*%D[i,]
for(i in 1:n) d[i]<-t(D[i,])%*%solve(varcov)%*%D[i,]
help("mahalanobis")
d
mahalanobis(X,center=colMeans(X),cov=var(X))
#                                     # the same
plot(d)
plot(qchisq(ppoints(d),df=p),sort(d),main="Chisq Q-Q plot of Mahalanobis distance",
xlab="Theoretical Quantiles",ylab="Sample Quantiles")
# 6)
## multivariate normality
n<-dim(DF)[1]
n
p<-dim(DF)[2]
p
X<-DF
# one<-rep(1,n)
# D<-as.matrix(X-one%*%t(bar.x))
D<-scale(DF,scale=F)
d<-rep(0,n)
for(i in 1:n) d[i]<-t(D[i,])%*%solve(varcov)%*%D[i,]
help("mahalanobis")
d
mahalanobis(X,center=colMeans(X),cov=var(X))
#                                     # the same
plot(d)
plot(qchisq(ppoints(d),df=p),sort(d),main="Chisq Q-Q plot of Mahalanobis distance",
xlab="Theoretical Quantiles",ylab="Sample Quantiles")
abline(0,1)
text(qchisq(ppoints(d),df=p),sort(d),label=order(d),
pos=4,cex=0.5,offset=0.3)
qqnorm(x1,pch=16,main="Q-Q plot for x1")
qqline(x1,col="red") #quite normal
# 5-6)
## multivariate normality
n<-dim(DF)[1]
n
p<-dim(DF)[2]
p
X<-DF
# one<-rep(1,n)
# D<-as.matrix(X-one%*%t(bar.x))
D<-scale(DF,scale=F)
d<-rep(0,n)
for(i in 1:n) d[i]<-t(D[i,])%*%solve(varcov)%*%D[i,]
help("mahalanobis")
d
mahalanobis(X,center=colMeans(X),cov=var(X))
#                                     # the same
plot(d)
plot(qchisq(ppoints(d),df=p),sort(d),main="Chisq Q-Q plot of Mahalanobis distance",
xlab="Theoretical Quantiles",ylab="Sample Quantiles")
abline(0,1)
text(qchisq(ppoints(d),df=p),sort(d),label=order(d),
pos=4,cex=0.5,offset=0.3)
skewness(X)
skewness(d)
skewness(p)
ppoints(d)
skewness(p)
skewness(d)
